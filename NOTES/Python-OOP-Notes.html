<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Python OOP Concepts</title>
	<meta name='Generator' content='Zim 0.65'>
	<style type='text/css'>
		a          { text-decoration: none      }
		a:hover    { text-decoration: underline }
		a:active   { text-decoration: underline }
		strike     { color: grey                }
		u          { text-decoration: none;
					 background-color: yellow   }
		tt         { color: #2e3436;            }
		pre        { color: #2e3436;
					 margin-left: 20px          }
		h1         { text-decoration: underline;
					 color: #4e9a06; margin-bottom: 0 }
		h2         { color: #4e9a06; margin-bottom: 0 }
		h3         { color: #4e9a06; margin-bottom: 0 }
		h4         { color: #4e9a06; margin-bottom: 0 }
		h5         { color: #4e9a06; margin-bottom: 0 }
		p          { margin-top: 0              }
		span.zim-tag {
			color: #ce5c00;
		}
		div.zim-object {
			border-style:solid;
			border-width:1px;
		}
		.checked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8sMEGsKGkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAEBUlEQVRIx62V22tdRRTGf7Nn73P2ybntnNOe3NqkPTGgLTVUUZF6QatSLOKTPgqCIqLgQ0H/A1sQQbBYCBb1QfAxiC8tSO1FqHkwJVKtjdTGNraUmObsc9nXmfGh7cGYpM1D5nHWzPetteZb3wg2eB2YqYm4zSadsMtoboiNBH/3TE0awx6j+MRoxoTg/IYRvP19TQrJS0bzhdHGSyKFkLTtjSKwMjyiEz43ynhtP6bdjBCWyFobAf7eT7VhNF/q1FRbjYjmUohlCVPwnB+6FUxMTJipqSmUUhhjEGKd3bMT4ks/Y6oLBK2Yth8hHYtCJXOix7Nf7xLMzc0xOzvLzp078TyPNE3viW3QJPXzhNWbxFFKHCmMhoLn/FHodd48vGfhapdAacXQlkFK5dL6wIUm6fuTZPuvqDQhaMUYYyiVyuQr6rXDexYuAdi3tSv1ZJNs/R/CaszzT+1na88uXFnCEnJVgivBNN8uTJKmHQI/ptOOcXNZzMz9mOqFs90OHpipWcYwlo5P4ebnuOkrvr5wgrH+h3im7y36MzuwRXYZeKha/OhP0EkadFoxQSdGSotedR/+XwMc2XvKdNUFOFqZx6LKZWIiwjgkikNmLp/hm8sH+K1zjFTHXfBYdTi+eJArzXM0GxFxoBDCopLvo/fqEwi1XPkWkGqjFo2TgB1jOYZUKZTS/D1/ncmLh7jon0IbRWoiTi59ymzzJEEQE3cStNZsGxqlfPE57MBbOR8fP3hDGalOO9fq2DlBvmZw8xa2IxACGn6TydlD/O6f5OzSV/zif0cYhLQaEXGkKBbz7Ov/AOlXV1cxgBJRI3fuSTrpTawt18kWIZN1CFuaONI0w0WOXfsI43YIggh/KUSlhqxrMz74AkOZcWBm9QkH+Gw8NDLuITi+m0yzhluSyJzBLcpblUhFxywSRAEtPwQjsKVN30CNh0uvYuOubSHLtN3J0TO1j0pmBNuFbFWRK0gyPRZpktL2I5JQkclKakNlnh54g6ocvevUr/Ai2a7wineEkcJupA3S1Wg0nVZM2E6wbEF5U5G9Q++wI7sfR7h3N8HVNstykBfzH+KJEZwiWD0aIwxCgJ0R1Mu7GXOeJSuK93bZtQIle4D9pUNU5DC5jEsu55AvZakM5NicGyEj8uuz8bUCQgj67QfY671P3vEoeC69gy695U1U7NG7XV0pUwBjDJa1/JJlWWxzHuflzQe5FJ/GsgUVuZ2t8lEkTvfc0aNHb72flBhjVicQQqCUuvM3/M+WDVguWBrMVdDXEGZlBVEUrVCU9d9s5+fnaTQa2PZyPxEIhJaI1EEoZwX4ncynp6fXrmB4eJjR0VFarRbNZnP9P9rt9gohqNVq1Ov1ZbF/AZGev3hLJ2/zAAAAAElFTkSuQmCC)}
		.xchecked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8bDYnDxEwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAEK0lEQVRIx9WVS2hTWRjHf/eR3CY1nbxMH2YiZRQS6qO13YlMVxY3SnVcuNIBFezGpSADLoQqLu1sHJCqdCFSXFpw4YOCSH3BtFqttTNamabX3DS5bfO6uffMoglja3RGcDMHzuac7/z/53++//cd+L8P6VuCPQYZ8ADNgBd4J31DcDcQs+GnHByRocEDv0kfBSjAOlYCs11Q+gpwDegS8LMJ+3QIK0ATzEhV8Odnz5bzw8P4dJ25aJQ/WlvJ1df/K7hSLtOcTNI+Pk69rpMTgqIQhCDvh1/VSpw79+gRrRMTmLZNezLJJsPg+a5dmOEwQlFqg1sWG16/Jv7sGWXDwBACFQjC9HcwIMONKkGp4PGAJGEDS0IQmZlhnWnye3c3eiyGo6qr3WHbrJ+dJf7gAXI6zSIr72T7/fgzmT4FHnTBsgrQBfYvTU0km5vxz86iADnAm0rRPTWFt7cXZccOJJcLAGHb2K9ekT93jmwmwwdAAFpjI6Ntbfxw5879ag7l6o1sr5eHHR3IsRgeQK/M4sQE+YEB7JcvEY6zAj45SWFgAPPxYwzHoQxIkQjTPT0kIxE+Noj8sexFn4/xnh58iQTeSpHkHAdrbIzi0BCOrmNPTpK/eJHM3bt8sCyKQCiR4NWePWSiUZw1+ZLXJm4pFKLhzBlCsRh2RUXacVgeGaF47RrL58+zcP8+RrmMkCQinZ1EL1zAjERqmkH+tLYl1G3bCJw4QUjT0IA0MJfLMX/5MqmHD0nZNiUgtGULG/r7ccXjINWuWbnmqsuFu7sb/4EDNLlcBIEioNs2KUAFGmMxmk6dQm1tRZI+3xBqEkiShBQOox05Ql1nJ26gvuIUAWiKQnj/ftStW5Fk+YuF+NldsbBA4cYN9KdPmaso8Fc62ZJtk7l1C2t0FGdxESHE1xE4hkHh6lX0oSHSpRIewC/LrPf7CSgKNpCamkI/fZr8pUuIZBIcpyaBunahPp1mub+fDyMjGKUSChCsq6Nh717q9u2jbnSU0uAgRrFIwTThyhUCqRS+hgZKLS1fJvDm87SNjZGcnsYUAjcQ8vsJ9/Xh7u1FDgRQN20iks3iDA+zZFmYhQLqzZtsj8WY3L0baY2Sf55ICCKpFHUzM2SEQAJCHg+hY8fQDh5EDgRWDoRC1J88SePRo2geD0XAcBy8b98Sv3ePYDZbbf2rFQjLIphMsmDbaEBQVQkePox26BCSz7e6i4bDrDt+nGYhmBscpFAskheC4Js3bPR4qHphFYEnlcI7P4/jdqNpGu8TCe4oCsXr1z//F2ga3+/cSfTJE0qmSVYIsKzaOZDcbjKyzFIiwfvt21kMBLA07YsetzWNd+3tLLW0sH5igvT8PH9Go/z44kX+E4LGjg7GDYOcy4XlOEgLC//5P/5LCFzxOPLmzWyIx+m6fduu7v0NVGqyTSycKksAAAAASUVORK5CYII=)}
		.unchecked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8qAt8h3m8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA60lEQVRIx+2VsQqDMBRF70sCLg5OLoKgjk7+lJ/hh+STXBwcnRz8ArMEkrxOFktbaC3tULzTg5e8k5vADXDq70VbobXmvu/hvQczg4heHrJfXxQFuq67blZbMc8zpmlCXddIkgTOuZcBUko45zCOI6y1Nz2xFSEEZFmGOI7fGg4A3nsQEZqmuXOu9jallACAtm3fvmutNaIoAjM/dkBECCF89KCbk4eAb+kEnIAT8EsAM0OIz3hSyrssUvss8t5fg+uIrLXPs0gIgWVZYIyBUurQyYdheO4gz3NUVQVjDNZ1PfSjpWmKsixvehfB9GBZ3NndrgAAAABJRU5ErkJggg==)}
		ul {list-style-image: none}
		/* ul rule needed to reset style for sub-bullets */

		span.insen { color: grey                }

		.pages {
			max-width: 1000px;
			 padding-left: 320px;
		}
		.menu{
			float:left; width: 300px;
		}
		hr{clear:both;}
	</style>
</head>
<body>

<!-- Header -->
<div class='header'>
	[ <span class='insen'>Prev</span> ]

	[ <span class='insen'>Index</span> ]

	[ <span class='insen'>Next</span> ]
</div>

<hr />

<div class="menu">
<ul>
<li><b>Python OOP</b></li>
</ul>

</div>

<!-- Wiki content -->

<div class='pages'>
	<div class='heading'>
	<h1>Python OOP Concepts <a name='Programming:Python:Python OOP'></a></h1>
	</div>

	<div class='content'>
	<p>
Created on 9th January 2016<br>
---------------------------------
</p>

<p>
<ul>
<li>Notes taken from the SafariBooksOnline course "PYTHON BEYOND THE BASICS - OBJECT ORIENTED PROGRAMMING".</li>
</ul>
</p>

<h4>1. Everything in Python is an object, even numbers.</h4>

<br>

<p>
An object is a unit of data (having one or more attributes), of a particular class or type, with associated functionality (methods).
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;mylist = ["a", "b", "c"]
2&nbsp;mybool = True
3&nbsp;mynone = None
4&nbsp;
5&nbsp;def myfunc():
6&nbsp;    print("Hello")
7&nbsp;print(myfunc)</pre>
</div>

<br>

<h4>2. Every object has multiple attributes, some common across objects, some common to the type of the object.</h4>

<br>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;var = 5
2&nbsp;In [6]: dir(var)
3&nbsp;Out[6]: 
4&nbsp;['__abs__',
5&nbsp; '__add__',
6&nbsp; '__and__',
7&nbsp; '__bool__',
8&nbsp; '__ceil__',
9&nbsp; '__class__',
10&nbsp; '__delattr__',
11&nbsp; '__dir__',
12&nbsp; '__divmod__',
13&nbsp; '__doc__',
14&nbsp; '__eq__',
15&nbsp; '__float__',
16&nbsp; '__floor__',
17&nbsp; '__floordiv__',
18&nbsp; '__format__',
19&nbsp; '__ge__',
20&nbsp; '__getattribute__',
21&nbsp; '__getnewargs__',
22&nbsp; '__gt__',
23&nbsp; '__hash__',
24&nbsp; '__index__',
25&nbsp; '__init__',
26&nbsp; '__int__',
27&nbsp; '__invert__',
28&nbsp; '__le__',
29&nbsp; '__lshift__',
30&nbsp; '__lt__',
31&nbsp; '__mod__',
32&nbsp; '__mul__',
33&nbsp; '__ne__',
34&nbsp; '__neg__',
35&nbsp; '__new__',
36&nbsp; '__or__',
37&nbsp; '__pos__',
38&nbsp; '__pow__',
39&nbsp; '__radd__',
40&nbsp; '__rand__',
41&nbsp; '__rdivmod__',
42&nbsp; '__reduce__',
43&nbsp; '__reduce_ex__',
44&nbsp; '__repr__',
45&nbsp; '__rfloordiv__',
46&nbsp; '__rlshift__',
47&nbsp; '__rmod__',
48&nbsp; '__rmul__',
49&nbsp; '__ror__',
50&nbsp; '__round__',
51&nbsp; '__rpow__',
52&nbsp; '__rrshift__',
53&nbsp; '__rshift__',
54&nbsp; '__rsub__',
55&nbsp; '__rtruediv__',
56&nbsp; '__rxor__',
57&nbsp; '__setattr__',
58&nbsp; '__sizeof__',
59&nbsp; '__str__',
60&nbsp; '__sub__',
61&nbsp; '__subclasshook__',
62&nbsp; '__truediv__',
63&nbsp; '__trunc__',
64&nbsp; '__xor__',
65&nbsp; 'bit_length',
66&nbsp; 'conjugate',
67&nbsp; 'denominator',
68&nbsp; 'from_bytes',
69&nbsp; 'imag',
70&nbsp; 'numerator',
71&nbsp; 'real',
72&nbsp; 'to_bytes']
</pre>
</div>

<br>

<p>
<b>NOTE:</b> Many of the above attributes are for an integer object, which 'var' is. If the data type was different, many of the above would be attributes for that particular data type.
</p>

<p>
<b>IMPORTANT</b>: There are several attributes with the '__<u>X</u>__' notation. These are called 'PRIVATE' or 'MAGIC' attributes, which is internal to that specific data type.
</p>

<h4>3. Modules vs Classes</h4>

<br>

<p>
<ul>
<li>Modules may contain Classes (one or more), and usually denotes a python file which can be imported in another Python file. It's just a collection of one or more classes and functions. </li>
</ul>
</p>

<p>
<ul>
<li>A Class is just a grouping of common functionality and is not supposed to be imported in another python file. </li>
</ul>
</p>

<h4>4. Classes, Instances, Types, Methods, and Attributes</h4>

<br>

<p>
<ul>
<li>Class		: A blueprint for an Instance.</li>
<li>Instance	: A constructed object of the Class.</li>
<li>Type		: Indicates the Class the instance belongs to.</li>
<li>Attribute	: Any object value (object.attribute)</li>
<li>Method	: A "callable" attribute defined in the Class.</li>
<li>Example:</li>
</ul>
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;var = "hello, world"
2&nbsp;
3&nbsp;print(type(var))
4&nbsp;&lt;class 'str'&gt;
5&nbsp;
6&nbsp;print(var.upper)
7&nbsp;&lt;built-in method upper of str object at 0x7f764b72f1f0&gt;
8&nbsp;
9&nbsp;print(var.upper())
10&nbsp;HELLO, WORLD</pre>
</div>

<br>

<h4>5. Defining a Class</h4>

<br>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class MyClass(object):
2&nbsp;    pass
3&nbsp;    
4&nbsp;this_object = MyClass()</pre>
</div>

<br>

<h4>5.Every variable, functions etc.. defined inside a class is available for all of it's instances.</h4>

<br>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class TestClass(object):
2&nbsp;	value = 12
3&nbsp;	def new(self):
4&nbsp;		self.test = "test"
5&nbsp;
6&nbsp;testing = TestClass()</pre>
</div>

<p>
In the above code, we have a class, a variable named 'value', the function named 'new', as well as the attribute 'test' within the 'new' function. We create a new instance named 'testing' from the class 'TestClass'.
</p>

<p>
From now on, the instance 'testing' can access both 'value' and 'new', as shown below.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;&gt;&gt;&gt; testing.value
2&nbsp;12
3&nbsp;&gt;&gt;&gt; testing.new
4&nbsp;&lt;bound method TestClass.new of &lt;console.TestClass object at 0x7f2633d1b850&gt;&gt;
5&nbsp;&gt;&gt;&gt; testing.test
6&nbsp;'test'</pre>
</div>

<br>

<h4>6.What is "self"?</h4>

<br>

<p>
<ul>
<li>`self` is used as the first argument in the functions/methods written for a class.</li>
<li>In order to use the class, it has to be instantiated first by assigning it to an instance variable. This is identical to processes being spawned from a binary.</li>
<li>When the class is instantiated, `self` acts as a handle to various available methods within the class.</li>
<li>In reality, `self` acts as the instantiated instance itself, for each instance created from the class. This can be proved by printing the instance as well as 'self', as shown below.</li>
</ul>
</p>

<br>

<p>
<ul>
<li>First example, check the following code:</li>
</ul>
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Testing(object):
2&nbsp;	def value(self):
3&nbsp;		print("Value = 10")
4&nbsp;		print(self)  # Print out `self` to know what it is.
5&nbsp;
6&nbsp;test = Testing()
7&nbsp;test.value()
8&nbsp;print(test)</pre>
</div>

<br>

<p>
We have a class defined named 'Testing'. This class has a function called 'value'. We create an instance name 'test' from the class 'Testing'. 
</p>

<p>
The above code should print:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;Value = 10
2&nbsp;&lt;main.Testing object at 0x7fc006aa6e90&gt;
3&nbsp;&lt;main.Testing object at 0x7fc006aa6e90&gt;</pre>
</div>

<br>

<p>
<ul>
<li>Here we have an instance named `test`. Hence `self` is `test` itself. </li>
<li>If you have more instances, `self` is each one of these, when that particular instance gets executed. 
<ul>
<li>Remember that an instance is a copy of the `class` in memory, and multiple instances would be in various locations of the memory. From the above output, we prove that both the output of `self` and the `instance` are referring to the same memory location, which means they are same.</li>
</ul></li>
</ul>
</p>

<p>
<ul>
<li>Another example:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Testing(object):
2&nbsp;	def value(self):
3&nbsp;		print("self :", self)
4&nbsp;
5&nbsp;test1 = Testing()
6&nbsp;test2 = Testing()
7&nbsp;
8&nbsp;test1.value()
9&nbsp;test2.value()
10&nbsp;
11&nbsp;print("test1 :", test1)
12&nbsp;print("test2 :", test2)</pre>
</div>

<p>
This outputs the following:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;('self :', &lt;main.Testing object at 0x7efe41a78e90&gt;)  ⇐ test1
2&nbsp;('self :', &lt;main.Testing object at 0x7efe41a21290&gt;)  ⇐ test2
3&nbsp;
4&nbsp;('test1 :', &lt;main.Testing object at 0x7efe41a78e90&gt;) ⇐ test1
5&nbsp;('test2 :', &lt;main.Testing object at 0x7efe41a21290&gt;) ⇐ test2</pre>
</div>

<br>

<p>
We can see that there are two instances `test1` and `test2` from the class `Testing`. We print the instance as well as `self` for each, and can see the output stating the differences.
</p>

<p>
<ul>
<li>Another example:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Testing(object):
2&nbsp;	def value(self):
3&nbsp;		self.num = 10
4&nbsp;		print(self.num)
5&nbsp;
6&nbsp;test = Testing()
7&nbsp;test.value()
8&nbsp;print(test.num)</pre>
</div>

<p>
The output is :
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;10
2&nbsp;10</pre>
</div>

<p>
Here we can see that `self.num` (from the class `Testing`) as well as `test.num` from the instance are the same. This means that `self` and the instance `test` are the same.
</p>

<p>
## <b>Another example of SELF</b>
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [30]: import random
2&nbsp;
3&nbsp;In [31]: class MyClass(object):
4&nbsp;   ....:     def dothis(self):
5&nbsp;   ....:         self.rand_val = random.randint(1, 10)
6&nbsp;   ....:         
7&nbsp;
8&nbsp;In [32]: myinst = MyClass()
9&nbsp;
10&nbsp;In [33]: myinst.dothis()
11&nbsp;
12&nbsp;In [34]: print(myinst.rand_val)
13&nbsp;4
</pre>
</div>

<br>

<p>
<ul>
<li>In the code above, we're interested in 'self.rand_val'. </li>
<li>We should notice that 'rand_val' is not a method/function, but an attribute which was created within the function/method 'dothis()'. </li>
<li>We're assigning the value of 'random.randit(1, 10)' to 'self.rand_val', which means that we can call &lt;instance&gt;.rand_val and get the random value printed.</li>
</ul>
</p>

<br>

<h4>7. Instance Attributes</h4>

<br>

<p>
<ul>
<li>Instance methods are variables defined in the class.</li>
<li>They are accessed through the instance `instance.method()`.</li>
<li>When called through the instance, the instance is automatically passed as the 1st argument to the method (which is also called `self`)</li>
<li>Because of this automatic passing of the instance, instance methods are also called 'BOUND' methods, ie.. bound to the instance upon which it is called.</li>
</ul>
</p>

<p>
Check the code below:
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [1]: class Joe(object):
2&nbsp;   ...:     greeting = "Hello Joe"
3&nbsp;   ...:     
4&nbsp;
5&nbsp;In [2]: thisjoe = Joe()
6&nbsp;
7&nbsp;In [3]: print(thisjoe.greeting)
8&nbsp;Hello Joe
</pre>
</div>

<p>
In the above code snippet, we can do a print on thisjoe.greeting. Here, `thisjoe.greeting()` is not a method in the Class, but just a statement in the class.
</p>

<p>
Let's change the above code snippet and put 'greeting' within a separate function, ie.. a method.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [4]: class Joe(object):
2&nbsp;   ...:     def callme(self):
3&nbsp;   ...:         print("Calling 'callme' method with instance")
4&nbsp;   ...:         
5&nbsp;
6&nbsp;In [5]: thisjoe = Joe()
7&nbsp;
8&nbsp;In [6]: print(thisjoe.callme())
9&nbsp;
10&nbsp;Calling 'callme' method with instance
11&nbsp;
12&nbsp;None								&lt;&lt;== Check the 'None' output which is not what we expected.
</pre>
</div>

<br>

<p>
In the code above, we created a new method/function called 'callme()'. The 'None' output was printed when we tried to print the method 'callme()'. 
</p>

<p>
############<br>
############<br>
<b>NOTE:</b> 'None' is usually printed when the function doesn't <b>return</b> anything. Here the 'callme' function returns nothing and only has a print statement. Rather, we should be calling the method directly as below.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [4]: class Joe(object):
2&nbsp;   ...:     def callme(self):
3&nbsp;   ...:         print("Calling 'callme' method with instance")
4&nbsp;   ...:         
5&nbsp;
6&nbsp;In [5]: thisjoe = Joe()
7&nbsp;
8&nbsp;In [8]: thisjoe.callme()
9&nbsp;Calling 'callme' method with instance
</pre>
</div>

<br>

<p>
If the function 'callme()' was returning a proper value, you'd have been able to do a 'print' directly on a function. See the code below:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [9]: class Joe(object):
2&nbsp;   ...:     def callme(self):
3&nbsp;   ...:         return "Calling 'callme' method with instance"
4&nbsp;   ...:     
5&nbsp;
6&nbsp;In [10]: thisjoe = Joe()
7&nbsp;
8&nbsp;In [11]: print(thisjoe.callme())
9&nbsp;Calling 'callme' method with instance
10&nbsp;
11&nbsp;In [12]: thisjoe.callme()
12&nbsp;Out[12]: "Calling 'callme' method with instance"
</pre>
</div>

<p>
In the code above, we made the function 'callme()' return the string rather than wrap it in a print() function.<br>
##########<br>
##########
</p>

<br>

<h4>7.Over-riding a class attribute in an instance</h4>

<br>

<p>
An attribute defined in a class can be overridden in an instance created from the class. Remember that an instance is a copy of the class in memory, hence we can create multiple instances from a class, and those would be in different memory locations. 
</p>

<p>
Overriding an attribute in an instance means overriding the value it inherited from the class, with a new value, which is perfectly fine. Check the code below:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Testing(object):
2&nbsp;	def value(self):
3&nbsp;		self.num = 10  &lt;== Default value set to '10'.
4&nbsp;		print(self.num)
5&nbsp;
6&nbsp;test = Testing()
7&nbsp;test.value()
8&nbsp;test.num = 20   &lt;== Overrides 'num', with the value '20'.
9&nbsp;print(test.num)</pre>
</div>

<br>

<p>
Here we have a class named 'Testing', and it has an attribute named 'num' which is set to '10'. We created an instance named 'test', and then overrided the default value of '10' with '20', using 'test.num = 20'. 
</p>

<p>
The output is shown below:
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;10
2&nbsp;20</pre>
</div>

<br>

<h4>8.Three major pillars of Object Oriented Programming:</h4>

<br>

<p>
<ol type="a" start="1">
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Polymorphism</li>
</ol>
</p>

<h4>9.Encapsulation</h4>

<br>

<p>
<ul>
<li>Encapsulation is the first of the three pillars of OOP.</li>
<li>Encapsulation refers to the `safe storage` of data (as attributes) in an instance. </li>
<li>Data should only be accessed through instance methods.</li>
<li>Data set in a class as attributes should be safe from changes made by external processes. </li>
<li>Read more at:
<ul>
<li><a href="https://stackoverflow.com/questions/26216563/how-to-do-encapsulation-in-python" title="https://stackoverflow.com/questions/26216563/how-to-do-encapsulation-in-python" class="https">https://stackoverflow.com/questions/26216563/how-to-do-encapsulation-in-python</a></li>
<li><a href="https://importantshock.wordpress.com/2006/11/03/adventures-in-pythonic-encapsulation/" title="https://importantshock.wordpress.com/2006/11/03/adventures-in-pythonic-encapsulation/" class="https">https://importantshock.wordpress.com/2006/11/03/adventures-in-pythonic-encapsulation/</a></li>
<li><a href="http://zetcode.com/lang/python/oop/" title="http://zetcode.com/lang/python/oop/" class="http">http://zetcode.com/lang/python/oop/</a></li>
</ul></li>
</ul>
</p>

<p>
Example 1: 
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python
2&nbsp;
3&nbsp;class MyClass(object):
4&nbsp;
5&nbsp;	def set_val(self, val):
6&nbsp;		self.value = val
7&nbsp;
8&nbsp;	def get_val(self):
9&nbsp;		return self.value
10&nbsp;
11&nbsp;a = MyClass()
12&nbsp;b = MyClass()
13&nbsp;
14&nbsp;a.set_val(10)
15&nbsp;b.set_val(100)
16&nbsp;
17&nbsp;a.get_val()
18&nbsp;b.get_val()</pre>
</div>

<br>

<p>
In this example, we have two methods, `set_val` and `get_val`. The first one sets the `val` value while the second one prints/returns the value. 
</p>

<p>
In order to explain Encapsulation, let's check the slight variation introduced below to the above code example.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#/usr/bin/env python 
2&nbsp;
3&nbsp;class MyClass(object):
4&nbsp;
5&nbsp;    def set_val(self, val):
6&nbsp;        self.value = val
7&nbsp;
8&nbsp;    def get_val(self):
9&nbsp;        print(self.value)
10&nbsp;
11&nbsp;a = MyClass()
12&nbsp;b = MyClass()
13&nbsp;
14&nbsp;a.set_val(10)
15&nbsp;b.value = 1000			&lt;== Directly calling 'value' rather than going through the `set_val()` method.
16&nbsp;
17&nbsp;a.get_val()
18&nbsp;b.get_val()</pre>
</div>

<br>

<p>
Check the change above. We are using 'b.value = 1000`, to directly change the `value` attribute, rather than 
</p>

<h4>10.Inheritance</h4>

<br>

<p>
Inheritance is the feature by which a Class can inherit methods from other Classes. The Class which inherits the methods is called a `Child Class` (also Lower class) while the Class which lends the methods are called `Parent Class` (Super Class).
</p>

<p>
<ul>
<li>An example:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Date(object):
2&nbsp;	def get_date(self):
3&nbsp;		return "10-01-2016"
4&nbsp;
5&nbsp;class Time(Date):
6&nbsp;	def get_time(self):
7&nbsp;		return "07:57 PM"
8&nbsp;
9&nbsp;dt = Date()
10&nbsp;print(dt.get_date())
11&nbsp;
12&nbsp;tm = Time()
13&nbsp;print(tm.get_time())
14&nbsp;print(tm.get_date())  &lt;== 'get_date()' method inherited from 'Date' class.</pre>
</div>

<br>

<p>
In the above code snippet, we have two Classes 'Date' and 'Time'. The class 'Time' inherits methods and variables from the 'Date' class. Due to the inheritance, the 'tm' instance derived from the 'Time' Class can call the 'get_date' method defined in the 'Date' class.
</p>

<h4>11. Polymorphism</h4>

<br>

<p>
<ul>
<li>Polymorphism is the characteristic of being able to assign a different meaning or usage in different contexts. A not-so-clear/clean example is, different classes can have the same function name.</li>
<li>Polymorphism is the case where you can have a method with the same name in multiple classes, ie.. multiple classes with the same method (function) name. </li>
<li>Since the order of the lookup is 'instance' -&gt; 'class' -&gt; 'parent class', even if the 'class' and 'parent class' has functions with the same name, the instance will only pick up the first hit, ie.. from the 'class' and won't go to the parent class.</li>
</ul>
</p>

<p>
<ul>
<li>Check the following code:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Animal(object):
2&nbsp;
3&nbsp;	def init(self, name):
4&nbsp;		self.name = name
5&nbsp;
6&nbsp;	def eat(self, food):
7&nbsp;		print('{0} eats {1}'.format(self.name, food))
8&nbsp;
9&nbsp;class Dog(Animal):
10&nbsp;
11&nbsp;	def fetch(self, thing):
12&nbsp;		print('{0} goes after {1}'.format(self.name, thing))
13&nbsp;
14&nbsp;	def show_affection(self):
15&nbsp;		print('{0} wags tail'.format(self.name))
16&nbsp;
17&nbsp;class Cat(Animal):
18&nbsp;
19&nbsp;	def swatstring(self):
20&nbsp;		print('{0} shreds the strings'.format(self.name))
21&nbsp;
22&nbsp;	def show_affection(self):
23&nbsp;		print('{0} purrs'.format(self.name))
24&nbsp;
25&nbsp;for a in (Dog("Kittu"), Cat("Fluffy"), Dog("Jicky"), Cat("Tiger")):
26&nbsp;	a.show_affection()</pre>
</div>

<br>

<p>
In the above code, we have a function named 'show_affection' in both the 'Dog' and 'Cat' classes. Due to the feature of polymorphism, both can exist perfectly well. 
</p>

<p>
The code outputs:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;Kittu wags tail
2&nbsp;Fluffy purrs
3&nbsp;Jicky wags tail
4&nbsp;Tiger purrs</pre>
</div>

<br>

<p>
Another example for Polymorphism are the several inbuilt functions in Python. Take for example, the builtin function called 'len'. 
</p>

<p>
'len' is available for almost all types, such as strings, ints, floats, dictionaries, lists, tuples etc.. When len is called on a type, it actually calls the inbuilts private function '<u>len</u>' on that type. Every object type that supports 'len' will have a private '<u>len</u>' function inbuilt.
</p>

<p>
Hence, for example, a list type already has a '<u>len</u>()' function inbuilt in the Python code, and when you run the len() function on the data type, it checks if the <u>len</u> private function is available for that type or not. If it is available, it runs that.
</p>

<p>
Check the example below:
</p>

<p>
<ul>
<li><tt>A list to start with:</tt></li>
</ul>
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [3]: text = ["Hello", "Hallo", "Hola"]
2&nbsp;
3&nbsp;In [4]: len(text)
4&nbsp;Out[4]: 3
5&nbsp;
6&nbsp;In [5]: text.len    &lt;== We find that the 'list' type has a 'len()' function builtin.
7&nbsp;Out[5]: &lt;method-wrapper 'len' of list object at 0x7f03bb94aef0&gt;
8&nbsp;
9&nbsp;In [6]: text.len()
10&nbsp;Out[6]: 3</pre>
</div>

<br>

<p>
<ul>
<li><tt>A string as the next example</tt></li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [7]: test = "Testing"
2&nbsp;
3&nbsp;In [8]: len(test)
4&nbsp;Out[8]: 7
5&nbsp;
6&nbsp;In [9]: test.len   &lt;== We find that the 'string' type has a 'len()' function buitin.
7&nbsp;Out[9]: &lt;method-wrapper 'len' of str object at 0x7f03ba873060&gt;
8&nbsp;
9&nbsp;In [10]: test.len()
10&nbsp;Out[10]: 7</pre>
</div>

<br>

<p>
Almost all other builtins connect to a method available as a private function for that data type. To get a list of all such private functions defined for a data type, run 'dir()' on that data type.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;In [11]: dir(text)
2&nbsp;Out[11]: ['add', 'class', 'contains', 'delattr', 'delitem', 'delslice', 'doc', 'eq', 'format', 
3&nbsp;'ge', 'getattribute', 'getitem', 'getslice', 'gt', 'hash', 'iadd', 'imul', 'init', 'iter', 
4&nbsp;'le', 'len', 'lt', 'mul', 'ne', 'new', 'reduce', 'reduce_ex', 'repr', 'reversed', 'rmul', 
5&nbsp;'setattr', 'setitem', 'setslice', 'sizeof', 'str', 'subclasshook', 'append', 'count', 'extend', 
6&nbsp;'index', 'insert', 'pop', 'remove', 'reverse', 'sort']</pre>
</div>

<p>
Here, '<u>add</u>' binds to the '+' feature in Python, where as '<u>contains</u>' bind to the key word 'in'. '<u>eq</u>' binds to '=='. Not all private methods are such, but a lot are.
</p>

<h4>12.Duck Typing</h4>

<br>

<p>
Python supports Duck Typing, since we don't have to define a variable type (or custom types such as classes as well) like C. In C, we need to use 'int a = 10' to define an int, while in Python we can simply say 'a = 10' and have the interpreter interpret it properly at run time.
</p>

<p>
In computer programming with object-oriented programming languages, duck typing is a layer of programming language and design rules on top of typing. 
</p>

<p>
In other words, Duck typing refers to reading an objects attributes 
</p>

<p>
Typing is concerned with assigning a type to any object. Duck typing is concerned with establishing the suitability of an object for some purpose. With normal typing, suitability is assumed to be determined by an object's type only. In duck typing, an object's suitability is determined by the presence of certain methods and properties (with appropriate meaning), rather than the actual type of the object.
</p>

<p>
In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific class. For example, in a non-duck-typed language, one would create a function that requires that the object passed into it be of type Duck, in order to ensure that that function can then use the object's walk and quack methods. In a duck-typed language, the function would take an object of any type and simply call its walk and quack methods, producing a run-time error if they are not defined.
</p>

<p>
<ul>
<li>Read <a href="https://en.wikipedia.org/wiki/Duck_typing" title="https://en.wikipedia.org/wiki/Duck_typing" class="https">https://en.wikipedia.org/wiki/Duck_typing</a></li>
</ul>
</p>

<h4>13.The '__init__' Constructor</h4>

<br>

<p>
<ul>
<li>`<u>init</u>` is a 'private' and 'magic' method which is used to set attributes while a new instance is initialized. </li>
<li>It is called 'private' due to it not being accessible (modifiable) in instances (Private methods use '__' both at start and end)</li>
<li>It is called a 'magic' function since it is called automatically when a new instance is initialized from that class.</li>
<li><u>init</u> is a python keyword and it should be called init and nothing else.</li>
<li>If it's not present in the class, it's not called.</li>
<li>'self' is used in this function, as any other functions defined inside a class.</li>
<li>The <u>init</u> constructor offers the opportunity to initialize attributes in the instance at the time of initialization.</li>
</ul>
</p>

<p>
<ul>
<li>Check the code:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class MyNum(object):
2&nbsp;	def init(self):
3&nbsp;		print("Calling init!")
4&nbsp;		self.val = 0
5&nbsp;
6&nbsp;	def increment(self):
7&nbsp;		self.val += 1
8&nbsp;
9&nbsp;dd = MyNum()
10&nbsp;print(dd.val)
11&nbsp;dd.increment()
12&nbsp;print(dd.val)</pre>
</div>

<br>

<p>
Here we use the <u>init</u> method to set a attribute to '0'. Another function named 'increment' adds the value. In the instance we create named 'dd', we can see that the first print will print '0' (which has been set at <u>init</u>) while the second one prints 1 since it's printed after 'dd.increment' function.
</p>

<p>
<ul>
<li>Another larger example</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class MyNum(object):
2&nbsp;	def init(self, value):
3&nbsp;		print("Calling init!")
4&nbsp;		self.val = value
5&nbsp;
6&nbsp;	def increment(self):
7&nbsp;		self.val += 1
8&nbsp;
9&nbsp;dd = MyNum("Hello")
10&nbsp;print(dd.val)
11&nbsp;print("Calling the `increment` method!")
12&nbsp;dd.increment()
13&nbsp;print(dd.val)</pre>
</div>

<p>
In the above code, we're trying to pass a string to the <u>init</u> method, which of course works fine, but passing that string through the increment function will fail since a str and int can't be concatenated.
</p>

<h4>14.Class attributes vs Instance attributes</h4>

<br>

<p>
<ul>
<li>Attributes set in a class is called Class Attributes</li>
<li>Attributes set in an instance is called Instance Attributes.</li>
<li>An instance has access to both Class Attributes and Instance Attributes.</li>
<li>An instance can be used to override both Class Attribues and Instance Attributes.</li>
<li>Check the example below:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class YourClass(object):
2&nbsp;	classy = 10
3&nbsp;
4&nbsp;	def set_val(self):
5&nbsp;		self.insty = 100
6&nbsp;
7&nbsp;dd = YourClass()
8&nbsp;
9&nbsp;dd.set_val()
10&nbsp;print("Original value of 'classy' : ", dd.classy)
11&nbsp;print("Original value of 'insty' : ", dd.insty)
12&nbsp;
13&nbsp;print("\nChanging value of 'classy' in instance 'dd' !")
14&nbsp;dd.classy = 50
15&nbsp;print("Changed value of 'classy' : ", dd.classy)
16&nbsp;
17&nbsp;print("\nChanging value of 'insty' in instance 'dd' !")
18&nbsp;dd.insty = 200
19&nbsp;print("Changed value of 'insty' : ", dd.insty)</pre>
</div>

<p>
<ul>
<li>This prints out:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;("Original value of 'classy' : ", 10)
2&nbsp;("Original value of 'insty' : ", 100)
3&nbsp;
4&nbsp;Changing value of 'classy' in instance 'dd' !
5&nbsp;("Changed value of 'classy' : ", 50)
6&nbsp;
7&nbsp;Changing value of 'insty' in instance 'dd' !
8&nbsp;("Changed value of 'insty' : ", 200)</pre>
</div>

<p>
<ul>
<li>The order in which attributes are looked up in an instance (First Instance attributes and then Class attributes)</li>
</ul>
</p>
<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class YourClass(object):
2&nbsp;	classy = "Class value"
3&nbsp;
4&nbsp;dd = YourClass()
5&nbsp;print("Original value of 'classy' :", dd.classy)
6&nbsp;print("Changing the value of 'classy' in instance 'dd' !")
7&nbsp;dd.classy = "Inst value"
8&nbsp;print("Changed value of 'classy' : ", dd.classy)
9&nbsp;print("Deleting the changed value of 'classy'")
10&nbsp;del(dd.classy)
11&nbsp;print("Printing the value of 'classy' after the deletion set in instance 'dd'")
12&nbsp;print(dd.classy)</pre>
</div>

<br>

<p>
This shows that the first lookup for any attribute is happening in the instance, and then the class. This is how we can override attributes in the class via instances.
</p>

<h4>15.Inheriting the __init__ Constructor</h4>

<br>

<p>
A child class inherits all its parent class' methods, including the <u>init</u> constructor. As you can see in the example, below:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class Animal(object):
2&nbsp;
3&nbsp;	def init(self, name):
4&nbsp;		self.name = name
5&nbsp;
6&nbsp;	def eat(self, food):
7&nbsp;		print("%s is eating %s" % (self.name, food))
8&nbsp;
9&nbsp;class Dog(Animal):
10&nbsp;
11&nbsp;	def fetch(self, thing):
12&nbsp;		print("%s goes after %s" % (self.name, thing))
13&nbsp;
14&nbsp;d = Dog('kittu')
15&nbsp;print(d.name)
16&nbsp;d.fetch("Boomerang")</pre>
</div>

<br>

<p>
The 'Dog' class inherits the '<u>init</u>' constructor/method from 'Animal' and that is why we were able to create an instance 'd' by passing 'kittu' to the 'Dog' class. While creating the instance, python first checks the 'Dog' class for an <u>init</u> constructor, and if it can't find one, it will go to the parent class (if any), and check for the same. Here it found it in the parent class.
</p>

<p>
<ul>
<li>Let's see a more robust inheritance method:</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;import random
2&nbsp;
3&nbsp;class Animal(object):
4&nbsp;
5&nbsp;    def __init__(self, name):
6&nbsp;        self.name = name
7&nbsp;
8&nbsp;class Dog(Animal):
9&nbsp;
10&nbsp;    def __init__(self, name):
11&nbsp;        super(Dog, self).__init__(name)
12&nbsp;        self.breed = random.choice(["Labrador", "Pug", "Retriever"])
13&nbsp;
14&nbsp;    def fetch(self, thing):
15&nbsp;        print("%s goes after %s!" % (self.name, thing))
16&nbsp;
17&nbsp;d = Dog("dogname")
18&nbsp;print(d.name)
19&nbsp;print(d.breed)</pre>
</div>

<br>

<p>
The entire code is not imporant per se. It's the 'super()' builtin function we're looking at. The above example, shows how we can call the <u>init</u> function (or any other function for that matter) from a parent class when we have a similar named class in the class we've the instance created from. 
</p>

<p>
Here, we're calling the <u>init</u> of the 'Animal' class, overriding the <u>init</u> of the 'Dog' class, even if the instance was created from 'Dog'.
</p>

<p>
NOTE: In python v3, we can write super() as :
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;super(Dog).init()</pre>
</div>

<br>

<h4>16.Multiple Inheritance</h4>

<br>

<p>
<ul>
<li>Multiple Inheritance Example 1</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python
2&nbsp;
3&nbsp;# multiple-inheritance-1.py
4&nbsp;
5&nbsp;# Python supports multiple inheritance
6&nbsp;# and uses a depth-first order when searching for methods.
7&nbsp;# This search pattern is call MRO (Method Resolution Order)
8&nbsp;
9&nbsp;# This is the first example, which shows the lookup of 'dothis()'.
10&nbsp;# As per the MRO output, it starts in class D, then B, A, and lastly C.
11&nbsp;
12&nbsp;# Both A and C contains 'dothis()'. Let's trace how the lookup happens.
13&nbsp;
14&nbsp;# As per the MRO output, it starts in class D, then B, A, and lastly C.
15&nbsp;# Starts looking in D, then moves to B, then to A.
16&nbsp;# A defines 'dothis()' and the search ends there. It doesn't go to C.
17&nbsp;
18&nbsp;# The MRO will show the full resolution path even if the full path is
19&nbsp;# not traversed.
20&nbsp;
21&nbsp;class A(object):
22&nbsp;
23&nbsp;    def dothis(self):
24&nbsp;        print("doing this in A")
25&nbsp;
26&nbsp;class B(A):
27&nbsp;    pass
28&nbsp;
29&nbsp;class C(object):
30&nbsp;
31&nbsp;    def dothis(self):
32&nbsp;        print("doing this in C")
33&nbsp;
34&nbsp;class D(B, C):
35&nbsp;    pass
36&nbsp;
37&nbsp;d_instance = D()
38&nbsp;
39&nbsp;d_instance.dothis()
40&nbsp;
41&nbsp;print("\nPrint the Method Resolution Order")
42&nbsp;print(D.mro())</pre>
</div>

<br>

<p>
<ul>
<li>Multiple Inheritance Example 2</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python
2&nbsp;
3&nbsp;# multiple-inheritance-2.py
4&nbsp;
5&nbsp;# Python supports multiple inheritance
6&nbsp;# and uses a depth-first order when searching for methods.
7&nbsp;# This search pattern is call MRO (Method Resolution Order)
8&nbsp;
9&nbsp;# This is a second example, which shows the lookup of 'dothis()'.
10&nbsp;# Both A and C contains 'dothis()'. Let's trace how the lookup happens.
11&nbsp;
12&nbsp;# As per the MRO output, it starts in class D, then B, A, and lastly C.
13&nbsp;# Starts looking in D, then moves to B, then to A.
14&nbsp;# A defines 'dothat' which is not what we're looking for.
15&nbsp;# Hence it goes back to D, then C, and finds it there.
16&nbsp;
17&nbsp;
18&nbsp;class A(object):
19&nbsp;
20&nbsp;    def dothat(self):
21&nbsp;        print("Doing this in A")
22&nbsp;
23&nbsp;class B(A):
24&nbsp;    pass
25&nbsp;
26&nbsp;class C(object):
27&nbsp;
28&nbsp;    def dothis(self):
29&nbsp;        print("\nDoing this in C")
30&nbsp;
31&nbsp;class D(B, C):
32&nbsp;    """Multiple Inheritance,
33&nbsp;    D inheriting from both B and C"""
34&nbsp;    pass
35&nbsp;
36&nbsp;d_instance = D()
37&nbsp;
38&nbsp;d_instance.dothis()
39&nbsp;
40&nbsp;print("\nPrint the Method Resolution Order")
41&nbsp;print(D.mro())</pre>
</div>

<br>

<p>
<ul>
<li>Multiple Inheritance Example 3 - "Diamond Shaped Inheritance"</li>
</ul>
</p>

<p>
"Diamond Problem" or "Deadly diamond of death" or "Diamond Shaped Inheritance" is a problem that can come up in the case of multiple inheritance. 
</p>

<br>

<p>
<img src="./Python-OOP-Notes_files/220px-Diamond_inheritance.svg.png">
</p>

<br>

<p>
From Wikipedia <a href="https://en.wikipedia.org/wiki/Multiple_inheritance" title="https://en.wikipedia.org/wiki/Multiple_inheritance" class="https">https://en.wikipedia.org/wiki/Multiple_inheritance</a>:
</p>

<p>
<i>The "diamond problem" (sometimes referred to as the "deadly diamond of death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?</i>
</p>

<p>
<i>For example, in the context of GUI software development, a class Button may inherit from both classes Rectangle (for appearance) and Clickable (for functionality/input handling), and classes Rectangle and Clickable both inherit from the Object class. Now if the equals method is called for a Button object and there is no such method in the Button class but there is an overridden equals method in Rectangle or Clickable (or both), which method should be eventually called?</i>
</p>

<p>
<i>It is called the "diamond problem" because of the shape of the class inheritance diagram in this situation. In this case, class A is at the top, both B and C separately beneath it, and D joins the two together at the bottom to form a diamond shape.</i>
</p>

<p>
A much better explanation (if the above Wikipedia excerpt doesn't make sense), can be seen in the SafariOnline Video Tutorial "<a href="https://www.safaribooksonline.com/library/view/python-beyond-the/9781771373609/" title="https://www.safaribooksonline.com/library/view/python-beyond-the/9781771373609/" class="https">https://www.safaribooksonline.com/library/view/python-beyond-the/9781771373609/</a>", from where these notes are taken.
</p>

<br>

<p>
<img src="./Python-OOP-Notes_files/Diamond-Shaped-Inheritance.png" width="1000">
</p>

<br>

<p>
By the default depth-first lookup pattern, the lookup should be as following, in the above diagram.
</p>

<p>
D ⇒ B ⇒ A ⇒ C ⇒ A
</p>

<p>
Note for self: I'm not sure how this can get complex, since the resolution can finish at 'D ⇒ B ⇒ A', and not go to 'C' at all. But as per software design in Python, it's said that the above pattern will hit the "Diamond Problem", and hence the change in resolution order was brought up in the new style classes.
</p>

<p>
In order to solve this, the new-style classes in Python solves this by removing the first occurrence of the repeated class.
</p>

<p>
Hence 'D ⇒ B ⇒ A ⇒ C ⇒ A' becomes 'D ⇒ B ⇒ C ⇒ A'
</p>

<p>
The below code shows the "Diamond Problem" in code, and let's see the Method Resolution Order to understand the removal of the first occurrence of A.
</p>

<br>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python
2&nbsp;
3&nbsp;# multiple-inheritance-3.py
4&nbsp;
5&nbsp;# Example for "Diamond Shape" inheritance
6&nbsp;
7&nbsp;# Python supports multiple inheritance
8&nbsp;# and uses a depth-first order when searching for methods.
9&nbsp;# This search pattern is call MRO (Method Resolution Order)
10&nbsp;
11&nbsp;class A(object):
12&nbsp;
13&nbsp;    def dothis(self):
14&nbsp;        print("doing this in A")
15&nbsp;
16&nbsp;class B(A):
17&nbsp;    pass
18&nbsp;
19&nbsp;class C(A):
20&nbsp;
21&nbsp;    def dothis(self):
22&nbsp;        print("doing this in C")
23&nbsp;
24&nbsp;class D(B, C):
25&nbsp;    pass
26&nbsp;
27&nbsp;d_instance = D()
28&nbsp;
29&nbsp;d_instance.dothis()
30&nbsp;
31&nbsp;print("\nPrint the Method Resolution Order")
32&nbsp;print(D.mro())</pre>
</div>

<br>

<p>
This prints the following:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;$ python multiple-inheritance-3.py
2&nbsp;doing this in C
3&nbsp;
4&nbsp;Print the Method Resolution Order
5&nbsp;[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]</pre>
</div>

<p>
Here, the method resolution order has changed to incorporate the lookup change, and its now 
</p>

<p>
D ⇒ B ⇒ C ⇒ A
</p>

<p>
Hence, the rule used in Python to work around the "Diamond Problem" is a simple additional rule to the depth-first rule.
</p>

<p>
<b>If the same class appears in a Method Resolution Order, the earlier occurrences of this class are removed from the MRO.</b> 
</p>

<p>
<ul>
<li>Points to note:</li>
</ul>
</p>

<p>
<ol type="1" start="1">
<li>Any class can inherit from multiple classes.</li>
<li>Python normally uses a depth-first order when searching through inherited classes</li>
<li>But when two classes inherit from the same class, Python eliminates the first mention of that class from the method resolution order.</li>
<li>This style applies to the new-style classes, ie.. the classes which inherits from the class 'object'.</li>
</ol>
</p>

<h4>17.New Style classes in Python</h4>

<br>

<p>
New-style classes has been integrated into Python 2.7 and old-style classes has been removed in Python 3. The new style classes in Python inherits from the 'object' class. Hence if you are writing a new style class, your class will inherit from the 'object' class, as shown below:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python
2&nbsp;
3&nbsp;class MyNewClass(object):
4&nbsp;    """New style class"""
5&nbsp;    pass</pre>
</div>

<br>

<p>
&lt;More info to be added...&gt;
</p>

<h4>18.Instance methods</h4>

<br>

<p>
<u>Instance methods are the normal functions inside a class, which uses 'self' as its first argument.</u> 
</p>

<p>
When an instance is created from the class, the 'self' parameter is a binding to the class. This means that all functions defined inside a class with 'self as the first parameter is bound to the instances created from the class. 
</p>

<p>
Instance methods are also called 'Bound methods'. 
</p>

<p>
Example:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class PrintName(object):
2&nbsp;    def __init__(self, name):
3&nbsp;        self.name = name
4&nbsp;        
5&nbsp;    def get_name(self):
6&nbsp;        print("Hello %s" % self.name)
7&nbsp;        
8&nbsp; printname = PrintName("Arthur")
9&nbsp; printname.get_name()</pre>
</div>

<br>

<p>
In the above example, we create an instance named `printname`, and calls the 'get_name' method defined in the class 'PrintName'. Since 'self' is called in 'get_name' function, it is bound to any of the instances created from the 'PrintName' class. 
</p>

<p>
These are called Instance Methods. 
</p>

<h4>19.Decorators</h4>

<br>

<p>
<ul>
<li>A decorator is a special function which modifies a function.</li>
<li>A decorator is denoted with a '@' symbol.
<ul>
<li><u>NOTE: Both @classmethod and @staticmethod are decorators.</u></li>
<li>staticmethod and classmethod both use decorators for defining a method as a staticmethod or classmethod. </li>
</ul>
</li>
<li><span class="zim-tag">@classmethod</span> and <span class="zim-tag">@staticmethod</span> are decorators which modifies a function and make it a Class method and Static method respectively. More on Class methods and Static methods down below.</li>
</ul>
</p>

<h4>20.Class methods</h4>

<br>

<p>
NOTE: Class methods and Static methods are needed when we need to create functions/methods which need not be accessed by the instances created from the class.
</p>

<p>
<ul>
<li>staticmethod and classmethod both use decorators for defining a method as a staticmethod or classmethod. </li>
<li>Class methods are not bound to the instance created from the class.</li>
<li>Hence, class methods do not need to use 'self' as the first parameter.</li>
<li>A class method takes the class (not instance) as the argument and works with the class object.</li>
<li>Class methods or fuctions which are supposed to be class methods, has 'cls' as the first args rather than 'self'.</li>
<li>A Class method uses 'cls' as the first argument.</li>
<li>A Class method can be called without instantiating the class, using 'Class.classmethod()'.</li>
</ul>
</p>

<p>
As we've seen earlier, all methods defined in a class are available to its instances. But in certain cases, not all methods need to be available or related to the instances created from the class. 
</p>

<p>
There can be methods/functions that are related to the class itself pertaining to information that's within the class, and not to the instances defined from it. 
</p>

<p>
<ul>
<li>Imagine the following code, which uses Instance methods all through.</li>
</ul>
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python3
2&nbsp;
3&nbsp;class InstanceCounter(object):
4&nbsp;    count = 0
5&nbsp;
6&nbsp;    def __init__(self, val):
7&nbsp;        self.val = val
8&nbsp;        InstanceCounter.count += 1
9&nbsp;
10&nbsp;    def set_val(self, newvalue):
11&nbsp;        set.val = newvalue
12&nbsp;
13&nbsp;    def get_val(self):
14&nbsp;        return self.val
15&nbsp;
16&nbsp;    def get_count(self):
17&nbsp;        return InstanceCounter.count
18&nbsp;
19&nbsp;# Instances
20&nbsp;
21&nbsp;one = InstanceCounter(10)
22&nbsp;two = InstanceCounter(20)
23&nbsp;three = InstanceCounter(30)
24&nbsp;
25&nbsp;for i in (one, two, three):
26&nbsp;    print("Name of instance    : %s" % i)
27&nbsp;    print("Value of object     : %s" % i.val)
28&nbsp;    print("Number of instance  : %s\n" % i.get_count())</pre>
</div>

<br>

<p>
Here, we have a class named 'InstanceCounter' which has three four methods<br>
<ul style='padding-left: 30pt'>
<li><u>init</u>()</li>
<li>set_val()</li>
<li>get_val()</li>
<li>get_count()</li>
</ul>
</p>

<p>
All these methods are Instance methods since they have 'self'. This works absolutely fine in this case.
</p>

<p>
This prints the following:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;$ python class_methods.py
2&nbsp;
3&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fad69fa6690&gt;
4&nbsp;Value of object     : 10
5&nbsp;Number of instance  : 3
6&nbsp;
7&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fad69fa66d0&gt;
8&nbsp;Value of object     : 20
9&nbsp;Number of instance  : 3
10&nbsp;
11&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fad69fa6710&gt;
12&nbsp;Value of object     : 30
13&nbsp;Number of instance  : 3</pre>
</div>

<br>

<p>
But, if we check the code closer, we can see that the function/method 'get_count' is not particularly needed to be tied with an instance, since it just returns the number of instances instantiated. The number of instances instatiated (we have three instances instantitated in the above code) is denoted by a counter in the class, named 'count'.
</p>

<p>
Hence, this need not be a bound/instance method (but sure will work as instance method as well). We can change this to a Class method. 
</p>

<p>
Let's see how to do that.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python3
2&nbsp;
3&nbsp;class InstanceCounter(object):
4&nbsp;    count = 0
5&nbsp;
6&nbsp;    def __init__(self, val):
7&nbsp;        self.val = val
8&nbsp;        InstanceCounter.count += 1
9&nbsp;
10&nbsp;    def set_val(self, newvalue):
11&nbsp;        set.val = newvalue
12&nbsp;
13&nbsp;    def get_val(self):
14&nbsp;        return self.val
15&nbsp;
16&nbsp;    @classmethod
17&nbsp;    def get_count(cls):
18&nbsp;        return cls.count
19&nbsp;
20&nbsp;# Instances
21&nbsp;
22&nbsp;one = InstanceCounter(10)
23&nbsp;two = InstanceCounter(20)
24&nbsp;three = InstanceCounter(30)
25&nbsp;
26&nbsp;for i in (one, two, three):
27&nbsp;    print("Name of instance    : %s" % i)
28&nbsp;    print("Value of object     : %s" % i.val)
29&nbsp;    print("Number of instance  : %s\n" % i.get_count())
30&nbsp;    
31&nbsp;print("We can directly call a class method as 'Class.classmethod'")
32&nbsp;print(InstanceCounter.get_count())</pre>
</div>

<br>

<p>
In the above example,<u> we have changed the 'get_count' method to *not* be an instance method.</u>  To change the instance method to a class method, we did the following:
</p>

<p>
<ul>
<li>Changed 'self' to 'cls' which denotes it has no bindings to the Instances created from the class, but only to the class.</li>
<li>Added the decorator '@classmethod' just above the 'get_count()' function/method.</li>
</ul>
</p>

<p>
This prints the same output as the previous example, where 'get_count' was an instance method.
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;$ python class_methods.py
2&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fd5b2683690&gt;
3&nbsp;Value of object     : 10
4&nbsp;Number of instance  : 3
5&nbsp;
6&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fd5b26836d0&gt;
7&nbsp;Value of object     : 20
8&nbsp;Number of instance  : 3
9&nbsp;
10&nbsp;Name of instance    : &lt;__main__.InstanceCounter object at 0x7fd5b2683710&gt;
11&nbsp;Value of object     : 30
12&nbsp;Number of instance  : 3</pre>
</div>

<br>

<h4>21.Static methods</h4>

<br>

<p>
Further reading:<br>
<ul>
<li><a href="http://www.bogotobogo.com/python/python_differences_between_static_method_and_class_method_instance_method.php" title="http://www.bogotobogo.com/python/python_differences_between_static_method_and_class_method_instance_method.php" class="http">http://www.bogotobogo.com/python/python_differences_between_static_method_and_class_method_instance_method.php</a></li>
<li><a href="http://pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/" title="http://pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/" class="http">http://pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/</a></li>
</ul>
</p>

<p>
<ul>
<li>staticmethod and classmethod both use decorators for defining a method as a staticmethod or classmethod. </li>
</ul>
</p>

<p>
<ul>
<li>Static methods are similar to class methods in terms that the instance need not access certain methods defined in the class. </li>
</ul>
</p>

<p>
<ul>
<li>A static method requires no specific arguments such as 'self' or 'cls' because it's not a BOUND method to the class or instance.</li>
</ul>
</p>

<p>
<ul>
<li>A staticmethod is put within the class due to reasons such as a relation to the class. Hence </li>
</ul>
</p>

<p>
While class methods are those methods pertaining to the class, Static methods are the ones which are independent of both Classes and Instances. They need not be used by the class or the instance, and may have to do something independently, and may need not be accessed by the class or instance. Hence 'Static' methods.
</p>

<p>
Check the following code:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;class InstanceCounter(object):
2&nbsp;    count = 0
3&nbsp;
4&nbsp;    def __init__(self, val):
5&nbsp;        self.val = self.filterint(val)
6&nbsp;        InstanceCounter.count += 1
7&nbsp;
8&nbsp;    @staticmethod
9&nbsp;    def filterint(value):
10&nbsp;        if not isinstance(value, int):
11&nbsp;            print("Entered value is not an INT, value set to 0")
12&nbsp;            return 0
13&nbsp;        else:
14&nbsp;            return value
15&nbsp;
16&nbsp;a = InstanceCounter(5)
17&nbsp;b = InstanceCounter(10)
18&nbsp;c = InstanceCounter(15)
19&nbsp;
20&nbsp;print(a.val)
21&nbsp;print(b.val)
22&nbsp;print(c.val)</pre>
</div>

<br>

<p>
This should print:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;$ python static_methods.py
2&nbsp;5
3&nbsp;10
4&nbsp;15</pre>
</div>

<br>

<p>
We have a class named 'InstanceCounter' here with a local variable named 'count' set to 0.
</p>

<p>
The <u>init</u> constructor takes in a 'val' variable. This variable is set after checking if the 'val' value is an int or not, through the 'filterint' function.
</p>

<p>
The 'filterint' function is just a check to confirm if the 'val' variable is an integer or not. Hence it need not be accessible from an instance. It also doesn't need to be accessed as a class method. Hence we are setting it as a static method.
</p>

<p>
NOTE: staticmethods can also be created as a function outside the class and called, since it need not be related to the class. But in case we need it inside the class due to the function's relation to the class, or if it's not used outside that particular class, we can set it up as a staticmethod.
</p>

<p>
NOTE: Even though the staticmethod does not require it to be bound to a class or an instance, it still can be called through the instance. See the code below:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;#!/usr/bin/env python3
2&nbsp;
3&nbsp;
4&nbsp;class InstanceCounter(object):
5&nbsp;    count = 0
6&nbsp;
7&nbsp;    def __init__(self, val):
8&nbsp;        self.val = self.filterint(val)
9&nbsp;        InstanceCounter.count += 1
10&nbsp;
11&nbsp;    @staticmethod
12&nbsp;    def filterint(value):
13&nbsp;        if not isinstance(value, int):
14&nbsp;            print("Entered value is not an INT, value set to 0")
15&nbsp;            return 0
16&nbsp;        else:
17&nbsp;            return value
18&nbsp;
19&nbsp;
20&nbsp;a = InstanceCounter(5)
21&nbsp;b = InstanceCounter(10)
22&nbsp;c = InstanceCounter(15)
23&nbsp;
24&nbsp;print(a.val)
25&nbsp;print(b.val)
26&nbsp;print(c.val)
27&nbsp;print(a.filterint(100))</pre>
</div>

<br>

<p>
This should print:
</p>

<div class="zim-object">
<pre class="brush: python;">
1&nbsp;$ python static_methods.py
2&nbsp;5
3&nbsp;10
4&nbsp;15
5&nbsp;100</pre>
</div>

<br>

<h4>22.Abstract Base Classes</h4>

<br>

<p>
Further reading:<br>
<ul>
<li><a href="http://zaiste.net/2013/01/abstract_classes_in_python/" title="http://zaiste.net/2013/01/abstract_classes_in_python/" class="http">http://zaiste.net/2013/01/abstract_classes_in_python/</a></li>
<li><a href="https://dbader.org/blog/abstract-base-classes-in-python" title="https://dbader.org/blog/abstract-base-classes-in-python" class="https">https://dbader.org/blog/abstract-base-classes-in-python</a></li>
<li><a href="https://pymotw.com/2/abc/" title="https://pymotw.com/2/abc/" class="https">https://pymotw.com/2/abc/</a></li>
<li><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" title="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" class="https">https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods</a></li>
</ul>
</p>

<p>
Abstract classes are used for creating a class blueprint which :
</p>

<p>
<ul>
<li>Can be subclassed by other classes. ie.. it can be called as a superclass in other classes.</li>
<li>Cannot be instantiated directly.</li>
</ul>
</p>

<h4>20.Method Overloading</h4>


	</div>

	<br />

	<div class='page-footer'>

			<b>Attachments:</b>
			<table>

			<tr><td><a href='./Python-OOP-Notes_files/220px-Diamond_inheritance.svg.png'>220px-Diamond_inheritance.svg.png</a></td><td>&nbsp;</td><td>6.12kb</td></tr>


			<tr><td><a href='./Python-OOP-Notes_files/Diamond-Shaped-Inheritance.png'>Diamond-Shaped-Inheritance.png</a></td><td>&nbsp;</td><td>393kb</td></tr>

			</table>
	</div>

	

</div>

</body>
</html>
